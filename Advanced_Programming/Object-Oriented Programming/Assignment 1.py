# -*- coding: utf-8 -*-
"""assignment1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10BU73_RG3JpNwGuzvDpWSsBwCTw7Qeti
"""

import random
import copy

ALTS_LIMIT = 4


def question_score(wrong_alt):
    return (2 * wrong_alt.chosen_times + 1) / (wrong_alt.displayed_time + 1)


class WrongAlt:
    def __init__(self, wrong_answer):
        self.content = wrong_answer
        self.chosen_times = 0
        self.displayed_time = 0
    
    def __str__(self):
        return self.content


class Question:
    """Represents Q&A

    attributes: question, answer, list of wrong answers"""

    def __init__(self, question, answer):
        self.question = question
        self.answer = answer
        self.wrong_answers = []

    def add_wrong(self, wrong_answer):
        self.wrong_answers.append(WrongAlt(wrong_answer))

    def ask(self):
        all_answers = copy.copy(self.wrong_answers)
        all_answers.sort(key=question_score)
        all_answers = all_answers[: ALTS_LIMIT - 1]
        all_answers.append(self.answer)
        random.shuffle(all_answers)
        correct_index = all_answers.index(self.answer) + 1
        print(self.question)
        for i, answer in enumerate(all_answers): 
            print(f'{i+1}: {answer}')

        user_answer = int(input('Which is your answer? '))
        return user_answer, correct_index


class Quiz:
    """Questions added to Quiz

    attributes: name, question"""

    def __init__(self, name):
        self.name = name
        self.questions = []

    def add_question(self, q):
        self.questions.append(q)

    def do(self):
        print(self.name)
        print('=' * len(self.name))
        total_questions = len(self.questions)
        total_correct = 0
        for q in self.questions:
            result = q.ask()
            if result[0] == result[1]:
                total_correct += 1
                print('Correct!')
                print()
            else:
                print(f'Incorrect! Correct answers is: {result[1]}')
                print()
        print(f'You answered {total_correct} of {total_questions} correctly.')

        return total_correct == total_questions

    def do_until_right(self):
        while not self.do():
            print("Sorry you didn't complete the quiz. Please try again.")
            print()
        print("You completed the quiz, well done! :)")


class IntQuestion(Question):
    """Question only with correct answer

    inherit from Question"""

    def ask(self):
        print(self.question)
        user_answer = input('Which is your answer? ')
        return user_answer, self.answer


def create_quiz_from_file(filename):
    with open(filename) as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            command, data = line.split(' ', 1)
            data = data.strip()
            qs_type = None
            if command == 'name':
                quiz = Quiz(data)
            elif command == 'q' or command == 'iq':
                text = data
                qs_type = command
            elif command == 'a':
                if qs_type == 'iq':
                    question = IntQuestion(text, data)
                elif qs_type == 'q':
                    question = Question(text, data)
                quiz.add_question(question)
            elif command == 'w':
                question.add_wrong(data)
    return quiz


class Digraph:
    """Class for directed graphs using list of edges and isolated nodes"""
    def __init__(self, vertices=[], edges=[]):
        self.vertices = vertices
        self.edges = edges

    def vertices(self):
        return self.vertices

    def edges(self):
        return self.edges

    def get_both(self):
        return self.edges, self.vertices

    def add_edge(self, source, dest):
        # append tuple
        self.edges.append((source, dest))
        # check if source or dest are in self.vertices
        if source not in self.vertices:
            self.vertices.append(source)
        if dest not in self.vertices:
            self.vertices.append(dest)
        # sorted to be aesthically pleasing :)
        self.vertices = sorted(self.vertices) 

    def add_edge2(self, source, dest):
        """Add edge by adding source and destination nodes and remove them from isolated vertices list if exist"""
        self.vertices.append((source, dest))
        if source in self.vertices:
            self.vertices.remove(source)
        if dest in self.vertices:
            self.vertices.remove(dest)

    # .remove_vertex(vertex) which removes a vertex and all edges from/to that vertex. 
    # no need to check if it's isolated
    def remove_vertex(self, vertex):
        for edge in self.edges:
            if vertex == edge[0] or vertex == [1]:
                self.edges.remove(edge)

    def is_transitive(self):
        full_node_list_dups = [t[0] for t in self.edges] + \
            [t[1] for t in self.edges] + \
            self.vertices
        full_node_list = list(set(full_node_list_dups))
        print(full_node_list)
        for v1 in full_node_list:
            for v2 in full_node_list:
                for v3 in full_node_list:
                    if (v1, v2) in self.edges \
                            and (v2, v3) in self.edges \
                            and not (v1, v3) in self.edges:
                        return False
        return True


# examples 

d = Digraph(vertices=[4], edges=[(1, 2), (1, 3), (2, 3), (3, 3)])
d_empty = Digraph()

# example 1 - edges going to and from the same vertex

for source, dest in d.edges:
    if source == dest:
        print(f"Detected loop from/to {source}")

# # example 1 - adding adge and removing vertex
#
# d.add_edge(3, 4)
# print(d.get_both())
# d.remove_vertex(4)
# print(d.get_both())
#
# # example 2 - empty Digraph
#
# print(d_empty.get_both())
# d_empty.add_edge(1, 2)
# d_empty.add_edge(2, 3)
# print(d_empty.get_both())
